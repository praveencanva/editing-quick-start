/**
 * @internal
 * A wrapper for messages
 */
export declare type Envelope<M> = {
    id: Envelope.Id;
    responseToId: Envelope.Id | undefined;
    content: M;
};
/**
 * @internal
 */
export declare namespace Envelope {
    type Id = number & {
        __envelopeId: never;
    };
    class Minter<M> {
        private nextEnvelopeId;
        mint<T extends M>(content: T, responseToId?: Envelope.Id): Envelope<T>;
    }
}
declare type Opts = {
    bufferSize: number;
    timeout: number;
};
/**
 * A mailbox for buffering messages. Add messages to the mailbox with
 * `enqueueMessage`, and pull them out of the mailbox with `receiveReply` or
 * `receiveMany`.
 *
 * Messages are kept in the mailbox until it is full, at which
 * point the oldest messages are removed to limit the size. The size of the
 * mailbox can be specified in the constructor.
 * @internal
 */
export declare class Mailbox<M> {
    private readonly opts;
    private handlers;
    private messages;
    constructor(opts: Opts);
    /**
     * Returns a Promise that resolves when the given message type
     * is received. If the message is already in the mailbox, the
     * promise will resolve immediately, otherwise it will continue
     * to listen until a matching message is received.
     */
    receiveReply<T extends M>(envelopeId: Envelope.Id, timeout?: number): Promise<Envelope<T>>;
    /**
     * Send a message and let any receivers pick it up
     */
    enqueueMessage(msg: Envelope<M>): void;
}
export {};
