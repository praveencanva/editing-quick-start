"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
// Edge doesn't support `toBlob`. Implementation below based on
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob#Polyfill
const canvasToBlob = (canvas, type, quality) => __awaiter(void 0, void 0, void 0, function* () {
    // use native canvas.toBlob, if available
    if (typeof canvas.toBlob === 'function') {
        const blob = yield new Promise((resolve, reject) => {
            try {
                canvas.toBlob(b => (b instanceof Blob ? resolve(b) : reject(b)), type, quality);
            }
            catch (e) {
                reject(e);
            }
        });
        return blob;
    }
    // roll this manually with a dataURL
    const dataUrl = canvas.toDataURL(type, quality).split(',')[1];
    const binStr = atob(dataUrl);
    const len = binStr.length;
    const arr = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        arr[i] = binStr.charCodeAt(i);
    }
    return new Blob([arr], { type: type || 'image/png' });
});
// From: https://stackoverflow.com/questions/12168909/blob-from-dataurl
// TODO(Jordan): Handle cases were URI is malformed
function dataURItoBlob(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    const byteString = atob(dataURI.split(',')[1]);
    // separate out the mime component
    const mimeString = dataURI
        .split(',')[0]
        .split(':')[1]
        .split(';')[0];
    // write the bytes of the string to an ArrayBuffer
    const ab = new ArrayBuffer(byteString.length);
    // create a view into the buffer
    const ia = new Uint8Array(ab);
    // set the bytes of the buffer to the correct values
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    // write the ArrayBuffer to a blob, and you're done
    return new Blob([ab], { type: mimeString });
}
const isSafari = navigator &&
    navigator.userAgent.match(/chrome/i) &&
    navigator.userAgent.match(/safari/i);
const blobToImage = (blob) => {
    return isSafari ? blobToImageViaReader(blob) : blobToImageViaObjectUrl(blob);
};
// slow path for Safari - it seems to have troubles with `createObjectURL` and race conditions
// `WebKitBlobResource error 1`
const blobToImageViaReader = (blob) => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function () {
            if (reader && reader.result instanceof ArrayBuffer) {
                const arrayBuffToImage = blobToImageViaObjectUrl(new Blob([new Uint8Array(reader.result)], { type: blob.type }));
                resolve(arrayBuffToImage);
            }
            else {
                reject('unknown error');
            }
        };
        reader.onerror = e => reject(e);
        reader.readAsArrayBuffer(blob);
    });
};
const blobToImageViaObjectUrl = (blob) => {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.crossOrigin = 'anonymous';
        const url = URL.createObjectURL(blob);
        image.onload = () => {
            resolve(image);
            URL.revokeObjectURL(url);
        };
        image.onerror = () => {
            console.error('blobToImage', 'failed');
            reject('Could not load image');
        };
        image.src = url;
    });
};
/**
 * @alpha
 */
var CanvaImage;
(function (CanvaImage) {
    CanvaImage.fromCanvas = (imageType, canvas, quality) => __awaiter(this, void 0, void 0, function* () {
        const blob = yield canvasToBlob(canvas, imageType, quality);
        if (blob instanceof Blob) {
            // console.log('blob resolve');
            const { width, height } = canvas;
            return { blob, imageType, width, height };
        }
        throw new Error('Could not create Blob from Canvas');
    });
    CanvaImage.fromDataUrl = (imageType, dataUrl) => __awaiter(this, void 0, void 0, function* () {
        const blob = dataURItoBlob(dataUrl);
        const { width, height } = yield blobToImage(blob);
        return {
            blob,
            imageType,
            width,
            height,
        };
    });
    CanvaImage.fromUrl = (url) => __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(url);
        const blob = yield response.blob();
        const imageType = blob.type;
        const { width, height } = yield blobToImage(blob);
        return {
            blob,
            imageType,
            width,
            height,
        };
    });
    CanvaImage.toImageElement = (t) => blobToImage(t.blob);
    CanvaImage.toDataUrl = (t) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => {
                if (reader.result && typeof reader.result === 'string') {
                    resolve(reader.result);
                }
                else {
                    reject('Unexpected FileReader result');
                }
            };
            reader.onerror = () => {
                reject('Error loading blob');
            };
            reader.readAsDataURL(t.blob);
        });
    };
    CanvaImage.getSize = (t) => ({
        width: t.width,
        height: t.height,
    });
})(CanvaImage = exports.CanvaImage || (exports.CanvaImage = {}));
