"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("./errors");
const iframe_client_comms_1 = require("./iframe_client_comms");
/**
 * API client provided to devs for use in their app iframes
 * Reduces boilerplate when interacting with host iFrame
 */
class CanvaApiClient {
    constructor(comms) {
        this.comms = comms;
        this.remoteProcessCounter = 0;
        this.onReceiveMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            // if the app has called exit() then don't send it any messages, but we can respond
            // to a save request in case messages got out of order over the wire
            if (this.exitingWithImage) {
                if (message.topic === "save_request" /* SAVE_REQUEST */) {
                    return Promise.resolve({
                        topic: "save_response" /* SAVE_RESPONSE */,
                        image: this.exitingWithImage,
                    });
                }
                return;
            }
            switch (message.topic) {
                case "controls_event" /* CONTROLS_EVENT */:
                    return this.handleControlsEvent(message);
                case "image_update" /* IMAGE_UPDATE */:
                    return this.handleImageUpdate(message);
                case "viewport_resize" /* VIEWPORT_RESIZE */:
                    return this.handleViewportResize(message);
                case "save_request" /* SAVE_REQUEST */:
                    return this.handleSaveRequest();
                case "init_request" /* INIT_REQUEST */:
                    return this.handleInitRequest(message);
                case "remote_process_started" /* REMOTE_PROCESS_STARTED */:
                case "remote_process_progress" /* REMOTE_PROCESS_PROGRESS */:
                case "remote_process_complete" /* REMOTE_PROCESS_COMPLETE */:
                    // console.log(`[Client] receieved ${message.topic}`);
                    if (this.remoteProcessStateMachine &&
                        message.processId === this.remoteProcessCounter) {
                        return this.remoteProcessStateMachine.receive(message);
                    }
                    else {
                        throw new Error(`Unsolicited ${message.topic} message received processId: ${message.processId}`);
                    }
                    break;
                case "presets_request" /* PRESETS_REQUEST */:
                    return this.handlePresetsRequest(message);
                case "preset_selected" /* PRESET_SELECTED */:
                    return this.handlePresetSelected(message);
                default:
                    throw new errors_1.UnreachableError('Unknown message type', message);
            }
        });
        this.comms = comms;
        this.comms.onMessage(this.onReceiveMessage);
    }
    static initialize(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            const messageChannel = new MessageChannel();
            const comms = new iframe_client_comms_1.IFrameClientBusComms(messageChannel.port1);
            const api = new CanvaApiClient(comms);
            yield handler(api);
            this.sendWakeUp(messageChannel.port2);
            return;
        });
    }
    /**
     * @internal
     */
    static sendWakeUp(port) {
        // console.log('[Client] Sending WAKE_UP event');
        window.parent.postMessage({
            topic: "wake_up" /* WAKE_UP */,
        }, '*', [port]);
    }
    /**
     * This function registers a callback that initializes an app.
     * @param handler Function that initializes an app. Both synchronous and asynchronous functions are supported.
     * @alpha
     */
    onReady(handler) {
        // console.log('setting onReady handler');
        this.readyHandler = handler;
    }
    /**
     * @alpha
     */
    onControlsEvent(handler) {
        // console.log('setting onControlsEvent handler');
        this.controlsEventHandler = handler;
    }
    /**
     * @alpha
     */
    onPresetsRequest(handler) {
        this.presetsRequestHandler = handler;
    }
    /**
     * @alpha
     */
    onPresetSelected(handler) {
        this.presetSelectedHandler = handler;
    }
    /**
     * @alpha
     */
    onSaveRequest(handler) {
        this.saveRequestHandler = handler;
    }
    /**
     * @alpha
     */
    onImageUpdate(handler) {
        if (this.imageUpdateHandler) {
            throw new Error('ImageUpdateHandler event handler has already been defined');
        }
        this.imageUpdateHandler = handler;
    }
    /**
     * @alpha
     */
    onViewportResize(handler) {
        if (this.viewportResizeHandler) {
            throw new Error('ViewportResize event handler has already been defined');
        }
        this.viewportResizeHandler = handler;
    }
    handleInitRequest(message) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // console.log('[Client] Received INIT_REQUEST');
                if (this.readyHandler) {
                    const { topic } = message, options = __rest(message, ["topic"]);
                    yield this.readyHandler(options);
                }
                // console.log('[Client] Sending INIT_RESPONSE');
                return {
                    topic: "init_response" /* INIT_RESPONSE */,
                };
            }
            catch (e) {
                // TODO Report the error
                console.error('[Client] Cannot run the extension:', e.message);
                console.error(e);
                // console.log('[Client] Sending INIT_RESPONSE (error = true)');
                return {
                    topic: "init_response" /* INIT_RESPONSE */,
                    error: true,
                };
            }
        });
    }
    overrideThumbnail(thumbnailId, thumbnail) {
        this.comms.castMessage({
            topic: "thumbnail_override" /* THUMBNAIL_OVERRIDE */,
            thumbnailId,
            thumbnail,
        });
    }
    updateControlPanel(controls, overlay) {
        this.comms.castMessage({
            topic: "controls_render" /* CONTROLS_RENDER */,
            controls,
            overlay,
        });
    }
    handleControlsEvent(message) {
        if (this.controlsEventHandler) {
            this.controlsEventHandler(message.message);
        }
    }
    handleImageUpdate(message) {
        const { image } = message;
        if (this.imageUpdateHandler) {
            this.imageUpdateHandler(image);
        }
    }
    handleViewportResize(message) {
        const { size, commit } = message;
        if (this.viewportResizeHandler) {
            this.viewportResizeHandler(size, commit);
        }
    }
    handleSaveRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.saveRequestHandler) {
                throw new Error('Received save request, but no handler configured.');
            }
            const image = yield this.saveRequestHandler();
            return {
                topic: "save_response" /* SAVE_RESPONSE */,
                image,
            };
        });
    }
    handlePresetsRequest(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.presetsRequestHandler) {
                throw new Error('Received presets request, but no handler configured.');
            }
            const presets = yield this.presetsRequestHandler({
                minDimensions: message.minDimensions,
                image: message.image,
            });
            return {
                topic: "presets_response" /* PRESETS_RESPONSE */,
                presets,
            };
        });
    }
    handlePresetSelected(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.presetSelectedHandler) {
                return;
            }
            this.presetSelectedHandler({ presetId: message.presetId });
        });
    }
    /**
     * @internal Remote processes aren't yet supported by third-party apps
     */
    remoteProcess(input, progressHandler, idHandler) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const onStart = (started) => idHandler && idHandler(started.inputImageId);
                const onProgress = (progress) => progressHandler &&
                    progressHandler(progress.label, progress.done, progress.total);
                const onComplete = (complete) => complete.result ? resolve(complete.result) : reject(complete.error);
                this.remoteProcessStateMachine = new RemoteProcessStateMachine(onStart, onProgress, onComplete);
                // console.log('[Client] sending START_REMOTE_PROCESS');
                this.comms.castMessage({
                    topic: "start_remote_process" /* START_REMOTE_PROCESS */,
                    processId: ++this.remoteProcessCounter,
                    input,
                });
            });
        });
    }
    /**
     * @alpha
     */
    exit(image) {
        this.exitingWithImage = image;
        this.comms.castMessage({
            topic: "exit" /* EXIT */,
            image,
        });
    }
}
exports.CanvaApiClient = CanvaApiClient;
class RemoteProcessStateMachine {
    constructor(onStart, onProgress, onComplete) {
        this.onStart = onStart;
        this.onProgress = onProgress;
        this.onComplete = onComplete;
        this.state = 'READY';
        this.startedMessage = undefined;
        this.progressMessages = [];
        this.completeMessage = undefined;
    }
    receive(message) {
        switch (message.topic) {
            case "remote_process_started" /* REMOTE_PROCESS_STARTED */:
                if (this.startedMessage) {
                    throw new Error(`Receieved too many ${message.topic} messages`);
                }
                this.startedMessage = message;
                break;
            case "remote_process_progress" /* REMOTE_PROCESS_PROGRESS */:
                this.progressMessages.push(message);
                break;
            case "remote_process_complete" /* REMOTE_PROCESS_COMPLETE */:
                if (this.completeMessage) {
                    throw new Error(`Receieved too many ${message.topic} messages`);
                }
                this.completeMessage = message;
                break;
            default:
                throw new errors_1.UnreachableError('Unknown message type', message);
        }
        this.handleMessages();
    }
    handleMessages() {
        switch (this.state) {
            case 'READY':
                if (this.startedMessage) {
                    this.onStart(this.startedMessage);
                    this.state = 'STARTED';
                    this.handleMessages();
                }
                break;
            case 'STARTED':
                if (this.progressMessages.length > 0) {
                    this.onProgress(this.progressMessages[0]);
                    this.progressMessages.shift();
                    this.handleMessages();
                }
                else if (this.completeMessage) {
                    this.onComplete(this.completeMessage);
                    this.state = 'DONE';
                }
                break;
            case 'DONE':
                // do nothing
                break;
            default:
                throw new errors_1.UnreachableError('Unknown state', this.state);
        }
    }
}
