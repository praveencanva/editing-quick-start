"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../");
class HostBus {
    constructor({ comms }) {
        // Amount of time an app is given to respond with an image
        this.SAVE_TIMEOUT = 20000;
        this.seq = 0;
        this.thumbnailOverrideHandler = new __1.EventHandler();
        this.controlsRenderHandler = new __1.EventHandler();
        this.saveRequested = false;
        /**
         * Handle incoming messages from iframes belonging to the dev.
         */
        this.onReceiveMessage = (message) => __awaiter(this, void 0, void 0, function* () {
            switch (message.topic) {
                case "controls_render" /* CONTROLS_RENDER */:
                    // console.log('[Host] Received CONTROLS_RENDER');
                    this.controlsRenderHandler.emit(this.seq++, message.controls, message.overlay);
                    break;
                case "thumbnail_override" /* THUMBNAIL_OVERRIDE */:
                    // console.log('[Host] Received THUMBNAIL_OVERRIDE');
                    this.thumbnailOverrideHandler.emit(message.thumbnailId, message.thumbnail);
                    break;
                case "start_remote_process" /* START_REMOTE_PROCESS */:
                    // console.log('[Host] Received START_REMOTE_PROCESS');
                    this.handleStartRemoteProcess(message);
                    break;
                case "exit" /* EXIT */:
                    // console.log('[Host] Received EXIT');
                    this.handleExit(message);
                    break;
                case "init_response" /* INIT_RESPONSE */:
                case "save_response" /* SAVE_RESPONSE */:
                case "presets_response" /* PRESETS_RESPONSE */:
                    throw new Error(`Unsolicited ${message.topic} response received`);
                default:
                    throw new __1.UnreachableError('Unknown message type', message);
            }
        });
        this.comms = comms;
        comms.onMessage(this.onReceiveMessage);
    }
    sendInitMessage(options) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log('[Host] Sending INIT_REQUEST');
            const response = yield this.comms.sendMessage(Object.assign({ topic: "init_request" /* INIT_REQUEST */ }, options));
            if (response.error) {
                throw new Error('Could not initialize the app');
            }
        });
    }
    sendControlsEvent(msg) {
        // console.log('[Host] Sending CONTROLS_EVENT');
        this.comms.castMessage({
            topic: "controls_event" /* CONTROLS_EVENT */,
            message: msg,
        });
    }
    sendViewportResize(size, commit) {
        // console.log('[Host] Sending VIEWPORT_RESIZE');
        this.comms.castMessage({
            topic: "viewport_resize" /* VIEWPORT_RESIZE */,
            commit,
            size,
        });
    }
    sendImageUpdate(image) {
        // console.log('[Host] Sending IMAGE_UPDATE');
        this.comms.castMessage({
            topic: "image_update" /* IMAGE_UPDATE */,
            image,
        });
    }
    // TODO: Add deserialize for type safety
    sendSaveRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log('[Host] Sending SAVE_REQUEST');
            this.saveRequested = true;
            const response = yield this.comms.sendMessage({
                topic: "save_request" /* SAVE_REQUEST */,
            }, this.SAVE_TIMEOUT);
            return response.image;
        });
    }
    onOverrideThumbnail(handler) {
        this.thumbnailOverrideHandler.addEventListener(handler);
    }
    onUpdateControlPanel(handler) {
        this.controlsRenderHandler.addEventListener(handler);
    }
    onRemoteProcess(handler) {
        this.remoteProcessHandler = handler;
    }
    onExit(handler) {
        this.exitHandler = handler;
    }
    sendPresetsRequest(image, minDimensions) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.comms.sendMessage({
                topic: "presets_request" /* PRESETS_REQUEST */,
                minDimensions,
                image,
            });
            return response.presets;
        });
    }
    sendPresetSelected(presetId) {
        this.comms.castMessage({
            topic: "preset_selected" /* PRESET_SELECTED */,
            presetId,
        });
    }
    handleStartRemoteProcess(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const { processId, input } = message;
            if (!this.remoteProcessHandler) {
                throw new Error('Received remote process request with no handler registered');
            }
            // console.log(`[Host] Received START_REMOTE_PROCESS processId: ${processId}`);
            // receive progress from the remoteProcessHandler and cast it to the comms
            const progressHandler = (label, done, total) => {
                // console.log(`[Host] Received REMOTE_PROCESS_PROGRESS processId: ${processId}`);
                this.comms.castMessage({
                    topic: "remote_process_progress" /* REMOTE_PROCESS_PROGRESS */,
                    processId,
                    label,
                    done,
                    total,
                });
            };
            const { inputImageId: inputImageIdPromise, result: resultPromise, } = this.remoteProcessHandler(input, progressHandler);
            // console.log(`[Host] Sending REMOTE_PROCESS_STARTED processId: ${processId}`);
            const inputImageId = yield inputImageIdPromise;
            this.comms.castMessage({
                topic: "remote_process_started" /* REMOTE_PROCESS_STARTED */,
                processId,
                inputImageId,
            });
            try {
                // console.log(`[Host] Sending REMOTE_PROCESS_COMPLETE (success) processId: ${processId}`);
                const result = yield resultPromise;
                this.comms.castMessage({
                    topic: "remote_process_complete" /* REMOTE_PROCESS_COMPLETE */,
                    processId,
                    result,
                });
            }
            catch (error) {
                // console.log(`[Host] Sending REMOTE_PROCESS_COMPLETE (error) processId: ${processId}`);
                this.comms.castMessage({
                    topic: "remote_process_complete" /* REMOTE_PROCESS_COMPLETE */,
                    processId,
                    error,
                });
            }
        });
    }
    handleExit(message) {
        if (!this.exitHandler) {
            throw new Error('EXIT called, but no handler registered');
        }
        // if the host has requested a save, then don't call the exitHandler
        if (this.saveRequested) {
            return;
        }
        this.exitHandler(message.image);
    }
}
exports.HostBus = HostBus;
