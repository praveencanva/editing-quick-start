"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const event_handler_1 = require("./event_handler");
const mailbox_1 = require("./mailbox");
/**
 * @internal
 */
class IFrameClientBusComms {
    constructor(port) {
        this.port = port;
        this.envelopeMinter = new mailbox_1.Envelope.Minter();
        this.mailbox = new mailbox_1.Mailbox({
            bufferSize: IFrameClientBusComms.MAILBOX_BUFFER_SIZE,
            timeout: IFrameClientBusComms.MESSAGING_TIMEOUT,
        });
        this.messageHandler = new event_handler_1.EventHandler();
        this.onPortMessage = (event) => {
            // console.log('[Client] Receiving event =', event);
            const message = event.data;
            if (message.responseToId != null) {
                this.mailbox.enqueueMessage(message);
            }
            this.messageHandler.emit(event);
        };
        this.port.onmessage = this.onPortMessage;
    }
    onMessage(handler) {
        this.messageHandler.addEventListener((event) => __awaiter(this, void 0, void 0, function* () {
            const message = event.data;
            if (message.responseToId == null) {
                const response = yield handler(message.content);
                if (response) {
                    this.respondTo(response, message.id);
                }
            }
        }));
    }
    castMessage(msg) {
        this.port.postMessage(this.envelopeMinter.mint(msg));
    }
    sendMessage(msg, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelope = this.envelopeMinter.mint(msg);
            // console.log('[Client] Sending Envelope =', envelope);
            this.port.postMessage(envelope);
            const response = yield this.mailbox.receiveReply(envelope.id, timeout);
            return response.content;
        });
    }
    respondTo(message, responseToId) {
        this.port.postMessage(this.envelopeMinter.mint(message, responseToId));
    }
}
exports.IFrameClientBusComms = IFrameClientBusComms;
IFrameClientBusComms.MAILBOX_BUFFER_SIZE = 5;
IFrameClientBusComms.MESSAGING_TIMEOUT = 5000;
