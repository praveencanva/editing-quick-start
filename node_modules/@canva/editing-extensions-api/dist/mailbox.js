"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 */
var Envelope;
(function (Envelope) {
    class Minter {
        constructor() {
            this.nextEnvelopeId = 0;
        }
        mint(content, responseToId) {
            return {
                id: this.nextEnvelopeId++,
                content,
                responseToId,
            };
        }
    }
    Envelope.Minter = Minter;
})(Envelope = exports.Envelope || (exports.Envelope = {}));
/**
 * A mailbox for buffering messages. Add messages to the mailbox with
 * `enqueueMessage`, and pull them out of the mailbox with `receiveReply` or
 * `receiveMany`.
 *
 * Messages are kept in the mailbox until it is full, at which
 * point the oldest messages are removed to limit the size. The size of the
 * mailbox can be specified in the constructor.
 * @internal
 */
class Mailbox {
    constructor(opts) {
        this.opts = opts;
        this.handlers = new Set();
        this.messages = [];
    }
    /**
     * Returns a Promise that resolves when the given message type
     * is received. If the message is already in the mailbox, the
     * promise will resolve immediately, otherwise it will continue
     * to listen until a matching message is received.
     */
    receiveReply(envelopeId, timeout) {
        // Scan mailbox for any existing matching messages
        for (const [i, msg] of this.messages.entries()) {
            if (msg.responseToId === envelopeId) {
                // Remove message from mailbox since it's handled
                this.messages.splice(i, 1);
                return Promise.resolve(msg);
            }
        }
        // Wait until matching message is received
        const receivePromise = new Promise(resolve => {
            const handler = (msg) => {
                if (msg.responseToId === envelopeId) {
                    this.handlers.delete(handler);
                    resolve(msg);
                    return true;
                }
                return false;
            };
            this.handlers.add(handler);
        });
        const timeoutPromise = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject(new Error('Mailbox timed out waiting for reply'));
            }, timeout || this.opts.timeout);
        });
        return Promise.race([receivePromise, timeoutPromise]);
    }
    /**
     * Send a message and let any receivers pick it up
     */
    enqueueMessage(msg) {
        // Is there already a handler that matches this message?
        for (const handler of this.handlers.values()) {
            if (handler(msg)) {
                // Handler handled this message
                return;
            }
        }
        // No current handlers, save the message in the mailbox for later
        this.messages.push(msg);
        if (this.messages.length > this.opts.bufferSize) {
            this.messages.shift();
        }
    }
}
exports.Mailbox = Mailbox;
