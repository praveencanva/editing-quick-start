
export declare interface BusComms<S extends Message.FromAny, R extends Message.FromAny> {
    /**
     * Sends a message to the app and returns the response
     */
    sendMessage<T extends R>(msg: S, timeout?: number): Promise<T>;
    /**
     * Sends a message to the app and doesn't expect a reply
     */
    castMessage(msg: S): void;
    /**
     * Adds a handler for incoming messages
     */
    onMessage(handler: Message.Handler<R, S>): void;
}

export declare namespace Button {
    export type Props = {
        id: string;
        label: string;
    };
    export type Config = ControlBase<ControlName.BUTTON> & Props;
    export type Message = {
        type: 'click';
    };
    const create: (props: Props) => Config;
}

/**
 * This type contains everything an editing extension needs to interact with Canva.
 * It lives at `window.canva`. In order to use it, add the following to your TypeScript definitions:
 *
 * ```
 * declare var window: Window & { canva: Canva };
 * ```
 */
export declare type Canva = {
    CanvaApiClient: typeof CanvaApiClient;
    CanvaImage: typeof CanvaImage;
    Button: typeof Button;
    Checkbox: typeof Checkbox;
    ColorPicker: typeof ColorPicker;
    Group: typeof Group;
    Page: typeof Page;
    Paragraph: typeof Paragraph;
    PreviewOverlay: typeof PreviewOverlay;
    ThumbnailList: typeof ThumbnailList;
    Select: typeof Select;
    Slider: typeof Slider;
    TextInput: typeof TextInput;
};

/**
 * API client provided to devs for use in their app iframes
 * Reduces boilerplate when interacting with host iFrame
 */
export declare class CanvaApiClient implements EditingExtensionClient.API {
    private readonly comms;
    static initialize(handler: (client: CanvaApiClient) => Promise<void>): Promise<void>;
    /**
     * @internal
     */
    private static sendWakeUp;
    private exitingWithImage?;
    private remoteProcessCounter;
    private remoteProcessStateMachine?;
    /**
     * @internal
     */
    protected controlsEventHandler?: EditingExtensionClient.ControlsEventHandler;
    /**
     * @internal
     */
    protected presetsRequestHandler?: EditingExtensionClient.PresetsRequestHandler;
    /**
     * @internal
     */
    protected presetSelectedHandler?: EditingExtensionClient.PresetSelectedHandler;
    /**
     * @internal
     */
    protected imageUpdateHandler?: EditingExtensionClient.ImageUpdateHandler;
    /**
     * @internal
     */
    protected viewportResizeHandler?: EditingExtensionClient.ViewportResizeHandler;
    /**
     * @internal
     */
    protected saveRequestHandler?: EditingExtensionClient.SaveRequestHandler;
    /**
     * @internal
     */
    protected readyHandler?: EditingExtensionClient.ReadyHandler;
    /**
     * This function registers a callback that initializes an app.
     * @param handler Function that initializes an app. Both synchronous and asynchronous functions are supported.
     * @alpha
     */
    onReady(handler: EditingExtensionClient.ReadyHandler): void;
    /**
     * @alpha
     */
    onControlsEvent(handler: EditingExtensionClient.ControlsEventHandler): void;
    /**
     * @alpha
     */
    onPresetsRequest(handler: EditingExtensionClient.PresetsRequestHandler): void;
    /**
     * @alpha
     */
    onPresetSelected(handler: EditingExtensionClient.PresetSelectedHandler): void;
    /**
     * @alpha
     */
    onSaveRequest(handler: EditingExtensionClient.SaveRequestHandler): void;
    /**
     * @alpha
     */
    onImageUpdate(handler: EditingExtensionClient.ImageUpdateHandler): void;
    /**
     * @alpha
     */
    onViewportResize(handler: EditingExtensionClient.ViewportResizeHandler): void;
    private constructor();
    private onReceiveMessage;
    private handleInitRequest;
    overrideThumbnail(thumbnailId: ThumbnailId, thumbnail: CanvaImage): void;
    updateControlPanel(controls?: Page.Config, overlay?: PreviewOverlay.Config): void;
    private handleControlsEvent;
    private handleImageUpdate;
    private handleViewportResize;
    private handleSaveRequest;
    private handlePresetsRequest;
    private handlePresetSelected;
    /**
     * @internal Remote processes aren't yet supported by third-party apps
     */
    remoteProcess(input: RemoteProcessInput, progressHandler?: EditingExtensionClient.RemoteProcessProgressHandler, idHandler?: EditingExtensionClient.RemoteProcessIdHandler): Promise<RemoteProcessOutput>;
    /**
     * @alpha
     */
    exit(image: ImageId | CanvaImage): void;
}

export declare namespace CanvaEditingExtensionHost {
    export type OverrideThumbnailHandler = (thumbnailId: ThumbnailId, image: CanvaImage) => void;
    export type UpdateControlPanelHandler = (seq: number, controls?: Page.Config, overlay?: PreviewOverlay.Config) => void;
    export type RemoteProcessProgressHandler = (label: string, done?: number, total?: number) => void;
    export type RemoteProcessHandler = (input: RemoteProcessInput, progressHandler: RemoteProcessProgressHandler) => {
        inputImageId: Promise<ImageId>;
        result: Promise<RemoteProcessOutput>;
    };
    export type ExitHandler = (image: ImageId | CanvaImage) => void;
    export interface API {
        /**
         * Updates preset thumbnail with a provided image
         */
        onOverrideThumbnail(handler: CanvaEditingExtensionHost.OverrideThumbnailHandler): void;
        /**
         * Update the controls shown in the control panel beside the canvas
         * TODO Decouple config from the messaging API
         */
        onUpdateControlPanel(handler: CanvaEditingExtensionHost.UpdateControlPanelHandler): void;
        /**
         * Handles user interaction events in the control panel beside the canvas
         * TODO Decouple config from the messaging API
         */
        sendControlsEvent(message: ControlMessage): void;
        /**
         * Register a Save handler
         * This will be invoked when the user presses the 'save' button.
         *
         * The handler MUST call `sendSaveResponse` in response
         */
        sendSaveRequest(): Promise<CanvaImage | ImageId>;
        /**
         * Tells the app to use a new image
         */
        sendImageUpdate(image: CanvaImage): void;
        /**
         * Handles viewport dimensions update
         */
        sendViewportResize(size: Size, commit?: boolean): void;
        /**
         * Register a handler to perform remote processing.
         */
        onRemoteProcess(handler: CanvaEditingExtensionHost.RemoteProcessHandler): void;
        /**
         * Register a handler for when the app wants to exit
         */
        onExit(handler: CanvaEditingExtensionHost.ExitHandler): void;
    }
}

/**
 * @alpha
 */
export declare type CanvaImage = {
    blob: Blob;
    imageType: string;
    width: number;
    height: number;
};

/**
 * @alpha
 */
export declare namespace CanvaImage {
    const fromCanvas: (imageType: string, canvas: HTMLCanvasElement, quality?: number | undefined) => Promise<CanvaImage>;
    const fromDataUrl: (imageType: string, dataUrl: string) => Promise<CanvaImage>;
    const fromUrl: (url: string) => Promise<CanvaImage>;
    const toImageElement: (t: CanvaImage) => Promise<HTMLImageElement>;
    const toDataUrl: (t: CanvaImage) => Promise<string>;
    const getSize: (t: CanvaImage) => Size;
}

export declare namespace Checkbox {
    export type Props = {
        id: string;
        label?: string;
        disabled?: boolean;
        checked?: boolean;
    };
    export type Config = ControlBase<ControlName.CHECKBOX> & Props;
    export type Message = {
        type: 'change';
        checked: boolean;
    };
    const create: (props: Props) => Config;
}

export declare namespace ColorPicker {
    export type Props = {
        id: string;
        label: string;
        color: string;
    };
    export type Config = ControlBase<ControlName.COLOR_PICKER> & Props;
    export type Message = {
        type: 'setColor';
        value: string;
    };
    const create: (props: Props) => Config;
}

export declare function connect(iframe: HTMLIFrameElement): Promise<IFrameHostBusComms>;

declare interface ControlBase<T extends ControlName> {
    type: T;
    id: string;
}

export declare type ControlConfig = Button.Config | TextInput.Config | Checkbox.Config | Paragraph.Config | ColorPicker.Config | Group.Config | Select.Config | Slider.Config | RadioGroup.Config | ThumbnailList.Config;

export declare type ControlMessage = MessageWrapper<ControlName.PAGE, Page.Message> | MessageWrapper<ControlName.BUTTON, Button.Message> | MessageWrapper<ControlName.TEXT_INPUT, TextInput.Message> | MessageWrapper<ControlName.CHECKBOX, Checkbox.Message> | MessageWrapper<ControlName.COLOR_PICKER, ColorPicker.Message> | MessageWrapper<ControlName.SELECT, Select.Message> | MessageWrapper<ControlName.SLIDER, Slider.Message> | MessageWrapper<ControlName.RADIO_GROUP, RadioGroup.Message> | MessageWrapper<ControlName.THUMBNAIL_LIST, ThumbnailList.Message>;

export declare const enum ControlName {
    BUTTON = "button",
    COLOR_PICKER = "color_picker",
    PAGE = "control_panel",
    GROUP = "group",
    SELECT = "select",
    SLIDER = "slider",
    THUMBNAIL_LIST = "thumbnail_list",
    TEXT_INPUT = "text_input",
    CHECKBOX = "checkbox",
    PARAGRAPH = "paragraph",
    RADIO_GROUP = "radio_group"
}

declare namespace EditingExtensionClient {
    type ReadyHandler = (opts: {
        previewSize: Size;
        /** Dictionary of translations provided by the app developer */
        localizedLabels: {
            [key: string]: string;
        };
        /** Dictionary of translations provided by Canva */
        canvaLabels: {
            [key: string]: string;
        };
        /** Dictionary of assets provided by the app developer */
        assets: {
            [key: string]: string;
        };
        image?: CanvaImage;
        imageId?: ImageId;
    }) => void | Promise<void>;
    type ControlsEventHandler = (message: ControlMessage) => void;
    type PresetsRequestHandler = (opts: {
        image: CanvaImage;
        minDimensions: Size;
    }) => Promise<Preset[]> | Preset[];
    type PresetSelectedHandler = (opts: {
        presetId: PresetId;
    }) => void;
    type SaveRequestHandler = () => Promise<CanvaImage | ImageId> | CanvaImage | ImageId;
    type ImageUpdateHandler = (image: CanvaImage) => void;
    type ViewportResizeHandler = (size: Size, commit?: boolean) => void;
    type RemoteProcessIdHandler = (imageId: ImageId) => void;
    type RemoteProcessProgressHandler = (label: string, done?: number, total?: number) => void;
    interface API {
        onReady(handler: ReadyHandler): void;
        /**
         * Called by the app when it wants to override a
         * thumbnail of the ThumbnailList component
         */
        overrideThumbnail(thumbnailId: ThumbnailId, thumbnail: CanvaImage): void;
        /**
         * Sent by the app when it wants to update the
         * controls visible in the app control panel
         * (the Canva contextual panel) or the overlay
         * on top of the preview.
         * TODO Decouple config from the messaging API
         */
        updateControlPanel(controls?: Page.Config, overlay?: PreviewOverlay.Config): void;
        /**
         * Called when the user interacts with a control in the app
         * control panel.
         * TODO Decouple config from the messaging API
         */
        onControlsEvent(handler: ControlsEventHandler): void;
        /**
         * Called when Canva wants to know which presets the app
         * provides.
         */
        onPresetsRequest(handler: PresetsRequestHandler): void;
        /**
         * Called when Canva wants the app to activate a specific preset
         */
        onPresetSelected(handler: PresetSelectedHandler): void;
        /**
         * Called when Canva has requested the edited image data
         * from the app, in order to save the image. For example,
         * when the user is happy with the image edits and clicks “Done”.
         */
        onSaveRequest(handler: SaveRequestHandler): void;
        /**
         * Called by Canva when it wants the app to use an updated image.
         * The app should preview effects based on the new image,
         * which replaces the image first given in `onReady`
         */
        onImageUpdate(handler: ImageUpdateHandler): void;
        /**
         * Called when the iframe size is changed, for example if
         * the image is resized while the app is open, or the
         * document zoom level changes.
         */
        onViewportResize(handler: ViewportResizeHandler): void;
        /**
         * Called by the app when it wants to process an image
         * using this App's server component.
         */
        remoteProcess(input: RemoteProcessInput, progressHandler?: RemoteProcessProgressHandler, idHandler?: RemoteProcessIdHandler): Promise<RemoteProcessOutput>;
        /**
         * Called by the app when it is done and wants to exit, once
         * this is called, then no handlers supplied by the app should be
         * called.
         */
        exit(image: ImageId | CanvaImage): void;
    }
}

/**
 * @internal
 * A wrapper for messages
 */
export declare type Envelope<M> = {
    id: Envelope.Id;
    responseToId: Envelope.Id | undefined;
    content: M;
};

/**
 * @internal
 */
export declare namespace Envelope {
    export type Id = number & {
        __envelopeId: never;
    };
    export class Minter<M> {
        private nextEnvelopeId;
        mint<T extends M>(content: T, responseToId?: Envelope.Id): Envelope<T>;
    }
}

/**
 * @internal
 */
export declare class EventHandler<E extends any[], R> {
    private readonly handlers;
    addEventListener(handler: (...args: E) => R): void;
    removeEventListener(handler: (...args: E) => R): void;
    emit(...args: E): void;
}

export declare namespace Group {
    export type Props = {
        id: string;
        label: string;
        children: ControlConfig[];
    };
    export type Config = ControlBase<ControlName.GROUP> & Props;
    const create: (props: Props) => Config;
}

export declare class HostBus implements CanvaEditingExtensionHost.API {
    private readonly SAVE_TIMEOUT;
    private seq;
    private readonly comms;
    private readonly thumbnailOverrideHandler;
    private readonly controlsRenderHandler;
    private remoteProcessHandler?;
    private exitHandler?;
    private saveRequested;
    constructor({ comms }: HostBusOptions);
    sendInitMessage(options: Omit<Message.InitRequest, 'topic'>): Promise<void>;
    sendControlsEvent(msg: ControlMessage): void;
    sendViewportResize(size: Size, commit?: boolean): void;
    sendImageUpdate(image: CanvaImage): void;
    sendSaveRequest(): Promise<CanvaImage | ImageId>;
    onOverrideThumbnail(handler: CanvaEditingExtensionHost.OverrideThumbnailHandler): void;
    onUpdateControlPanel(handler: CanvaEditingExtensionHost.UpdateControlPanelHandler): void;
    onRemoteProcess(handler: CanvaEditingExtensionHost.RemoteProcessHandler): void;
    onExit(handler: CanvaEditingExtensionHost.ExitHandler): void;
    /**
     * Handle incoming messages from iframes belonging to the dev.
     */
    private readonly onReceiveMessage;
    sendPresetsRequest(image: CanvaImage, minDimensions: Size): Promise<Preset[]>;
    sendPresetSelected(presetId: PresetId): void;
    private handleStartRemoteProcess;
    handleExit(message: Message.Exit): void;
}

declare type HostBusOptions = {
    comms: BusComms<Message.FromHost, Message.FromClient>;
};

declare class IFrameHostBusComms implements BusComms<Message.FromHost, Message.FromClient> {
    private readonly port;
    private static MAILBOX_BUFFER_SIZE;
    private static MESSAGING_TIMEOUT;
    private readonly mailbox;
    private envelopeMinter;
    private readonly messageHandler;
    constructor(port: MessagePort);
    onMessage(handler: Message.Handler<Message.FromClient, Message.FromHost>): void;
    castMessage(msg: Message.FromHost): void;
    sendMessage<T extends Message.FromClient>(msg: Message.FromHost, timeout?: number): Promise<T>;
    private respondTo;
    private onPortMessage;
}

/**
 * @alpha
 */
export declare type ImageId = string & {
    __imageId: never;
};

/**
 * A mailbox for buffering messages. Add messages to the mailbox with
 * `enqueueMessage`, and pull them out of the mailbox with `receiveReply` or
 * `receiveMany`.
 *
 * Messages are kept in the mailbox until it is full, at which
 * point the oldest messages are removed to limit the size. The size of the
 * mailbox can be specified in the constructor.
 * @internal
 */
export declare class Mailbox<M> {
    private readonly opts;
    private handlers;
    private messages;
    constructor(opts: Opts);
    /**
     * Returns a Promise that resolves when the given message type
     * is received. If the message is already in the mailbox, the
     * promise will resolve immediately, otherwise it will continue
     * to listen until a matching message is received.
     */
    receiveReply<T extends M>(envelopeId: Envelope.Id, timeout?: number): Promise<Envelope<T>>;
    /**
     * Send a message and let any receivers pick it up
     */
    enqueueMessage(msg: Envelope<M>): void;
}

export declare namespace Message {
    export type Handler<S extends FromAny, R extends FromAny> = (msg: S) => Promise<R | void> | void;
    export const enum Topic {
        WAKE_UP = "wake_up",
        INIT_REQUEST = "init_request",
        INIT_RESPONSE = "init_response",
        PRESETS_REQUEST = "presets_request",
        PRESETS_RESPONSE = "presets_response",
        PRESET_SELECTED = "preset_selected",
        CONTROLS_RENDER = "controls_render",
        CONTROLS_EVENT = "controls_event",
        THUMBNAIL_OVERRIDE = "thumbnail_override",
        IMAGE_UPDATE = "image_update",
        VIEWPORT_RESIZE = "viewport_resize",
        SAVE_REQUEST = "save_request",
        SAVE_RESPONSE = "save_response",
        START_REMOTE_PROCESS = "start_remote_process",
        REMOTE_PROCESS_STARTED = "remote_process_started",
        REMOTE_PROCESS_PROGRESS = "remote_process_progress",
        REMOTE_PROCESS_COMPLETE = "remote_process_complete",
        EXIT = "exit"
    }
    export type WakeUp = {
        topic: Topic.WAKE_UP;
    };
    export type InitRequest = {
        topic: Topic.INIT_REQUEST;
        previewSize: Size;
        localizedLabels: {
            [key: string]: string;
        };
        canvaLabels: {
            [key: string]: string;
        };
        assets: {
            [key: string]: string;
        };
        image?: CanvaImage;
        imageId?: ImageId;
    };
    export type InitResponse = {
        topic: Topic.INIT_RESPONSE;
        error?: true;
    };
    export type PresetsRequest = {
        topic: Topic.PRESETS_REQUEST;
        minDimensions: Size;
        image: CanvaImage;
    };
    export type PresetsResponse = {
        topic: Topic.PRESETS_RESPONSE;
        presets: Preset[];
    };
    export type PresetSelected = {
        topic: Topic.PRESET_SELECTED;
        presetId: PresetId;
    };
    export type ControlsRender = {
        topic: Topic.CONTROLS_RENDER;
        controls?: Page.Config;
        overlay?: PreviewOverlay.Config;
    };
    export type ControlsEvent = {
        topic: Topic.CONTROLS_EVENT;
        message: ControlMessage;
    };
    export type ImageUpdate = {
        topic: Topic.IMAGE_UPDATE;
        image: CanvaImage;
    };
    export type ViewportResize = {
        topic: Topic.VIEWPORT_RESIZE;
        commit?: boolean;
        size: Size;
    };
    export type SaveRequest = {
        topic: Topic.SAVE_REQUEST;
    };
    export type SaveResponse = {
        topic: Topic.SAVE_RESPONSE;
        image: CanvaImage | ImageId;
    };
    export type ThumbnailOverride = {
        topic: Topic.THUMBNAIL_OVERRIDE;
        thumbnailId: ThumbnailId;
        thumbnail: CanvaImage;
    };
    export type StartRemoteProcess = {
        topic: Topic.START_REMOTE_PROCESS;
        processId: number;
        input: RemoteProcessInput;
    };
    export type RemoteProcessStarted = {
        topic: Topic.REMOTE_PROCESS_STARTED;
        processId: number;
        inputImageId: ImageId;
    };
    export type RemoteProcessProgress = {
        topic: Topic.REMOTE_PROCESS_PROGRESS;
        processId: number;
        label: string;
        done?: number;
        total?: number;
    };
    export type RemoteProcessComplete = {
        topic: Topic.REMOTE_PROCESS_COMPLETE;
        processId: number;
        result?: RemoteProcessOutput;
        error?: string;
    };
    export type Exit = {
        topic: Topic.EXIT;
        image: CanvaImage | ImageId;
    };
    export type FromClient = InitResponse | ControlsRender | PresetsResponse | SaveResponse | ThumbnailOverride | StartRemoteProcess | Exit;
    export type FromHost = InitRequest | ControlsEvent | PresetsRequest | PresetSelected | ImageUpdate | ViewportResize | SaveRequest | RemoteProcessStarted | RemoteProcessProgress | RemoteProcessComplete;
    export type FromAny = FromClient | FromHost;
}

declare type MessageWrapper<ControlTypeName extends ControlName, ControlTypeMessage> = {
    controlType: ControlTypeName;
    controlId: string;
    commit: boolean;
    message: ControlTypeMessage;
};

declare type Opts = {
    bufferSize: number;
    timeout: number;
};

export declare namespace Page {
    export type Props = {
        subpage: false;
        controls: ControlConfig[];
    } | {
        subpage: true;
        title?: string;
        actionLabel?: string;
        controls: ControlConfig[];
    };
    export type Config = ControlBase<ControlName.PAGE> & Props;
    export type Message = {
        type: 'back' | 'action';
    };
    /**
     * @param controls List of controls to show in the page
     * @param subpage (Optional) Whether the app receives the back button event
     * @param title (Optional) i18n'd title shown in subpage header
     * @param action (Optional) i18n'd action shown in subpage header
     */
    const create: ({ subpage, title, actionLabel, controls, }: {
        subpage?: boolean | undefined;
        title?: string | undefined;
        actionLabel?: string | undefined;
        controls: ControlConfig[];
    }) => Config;
}

export declare namespace Paragraph {
    export type Props = {
        id: string;
        text: string;
    };
    export type Config = ControlBase<ControlName.PARAGRAPH> & Props;
    const create: (props: Props) => Config;
}

export declare type Preset = {
    id: string;
    label: string;
    image: CanvaImage;
};

export declare type PresetId = string & {
    __presetId: never;
};

export declare namespace PreviewOverlay {
    const type = "PREVIEW_OVERLAY";
    export type Props = {
        showSpinner: boolean;
        notification?: Notification;
    };
    export type Notification = {
        type: NotificationType;
        content: string;
    };
    export enum NotificationType {
        SUCCESS = "success",
        ERROR = "error",
        INFO = "info"
    }
    export type Config = {
        type: 'PREVIEW_OVERLAY';
    } & Props;
    const create: (props: Props) => Config;
}

export declare namespace RadioGroup {
    export type Button = {
        value: string;
        label: string;
        disabled?: boolean;
    };
    export type Props = {
        id: string;
        buttons: Button[];
        value?: string;
    };
    export type Config = ControlBase<ControlName.RADIO_GROUP> & Props;
    export type Message = {
        type: 'setValue';
        value: string;
    };
    const create: (props: Props) => Config;
}

export declare type RemoteProcessInput = {
    image?: CanvaImage | ImageId;
    settings?: Map<string, string>;
};

export declare type RemoteProcessOutput = {
    image?: CanvaImage;
    imageId?: ImageId;
};

export declare namespace Select {
    export type Option = {
        value: string;
        label: string;
        icon?: string;
    };
    /**
     * @internal
     */
    export type Props = {
        id: string;
        options: Option[];
        value: string | undefined;
    };
    export type Config = ControlBase<ControlName.SELECT> & Props;
    export type Message = {
        type: 'setValue';
        value: string;
    };
    const create: (props: Props) => Config;
}

export declare type SendMessageFn = (msg: ControlMessage) => void;

export declare type Size = {
    width: number;
    height: number;
};

export declare namespace Slider {
    export type Props = {
        id: string;
        label: string;
        value: number;
        min: number;
        max: number;
        step: number;
    };
    export type Config = ControlBase<ControlName.SLIDER> & Props;
    export type Message = {
        type: 'setValue';
        value: number;
    };
    const create: (props: Props) => Config;
}

export declare namespace TextInput {
    export interface InputType {
        id: string;
        placeholder?: string;
        label?: string;
        name?: string;
        disabled?: boolean;
    }
    export interface TextType {
        inputType?: 'text';
        value?: string;
        maxLength?: number;
    }
    export interface NumberType {
        inputType?: 'number';
        value?: number;
    }
    export type Props = InputType & (TextType | NumberType);
    export type Config = ControlBase<ControlName.TEXT_INPUT> & Props;
    export type Message = {
        type: 'change';
        value: Props['value'];
    };
    const create: (props: Props) => Config;
}

export declare type ThumbnailId = string & {
    __thumbnailId: never;
};

export declare namespace ThumbnailId {
    const create: (id: string) => ThumbnailId;
}

export declare namespace ThumbnailList {
    export type Item = {
        thumbnailId: string;
        label: string;
        defaultSrc: string;
    };
    export type Props = {
        id: string;
        items: Item[];
        selectedThumbnailId?: string;
        showNone?: boolean;
        showCustom?: boolean;
    };
    export type Config = ControlBase<ControlName.THUMBNAIL_LIST> & Props;
    export type Message = {
        type: 'selected';
        /** id of the thumbnail selected */
        thumbnailId: string;
    };
    const create: (props: Props) => Config;
}

/**
 * @alpha
 */
export declare class UnimplementedError extends Error {
}

/**
 * @alpha
 */
export declare class UnreachableError {
    constructor(description: string, message: never);
}

export { }
